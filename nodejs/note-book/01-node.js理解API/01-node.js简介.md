# node.js简介
## 一、对比
### 1、客户端的`JavaScript`是怎样的

>1.1 浏览器的作用：
>>- 请求一个HTTP地址（封装一个请求报文）
    ：浏览器的最大作用就是将一个`URL`地址封装成一个请求报文
>>- 解析服务器返回来的响应报文（内容有可能不一样）
    ：渲染`HTML`、`CSS`、`Image` ； 解释（执行）JS;

>1.2 什么是 `JavaScript`？
>>- 脚本语言
>>- 运行在浏览器中
>>- 一般用来做客户端页面的交互（`Interactive`）

>1.3 `JavaScript` 的运行环境？
>>- 是不是运行在浏览器呢？ 不够严谨
>>- 运行在浏览器内核中的 `JS` 引擎（engine）

>1.4 浏览器中的 `JavaScript` 可以做什么？
>>- 操作`DOM`（对`DOM`的增删改、注册事件）
>>- `AJAX`/跨域
>>- `BOM`（页面跳转、历史记录、`console.log()`、`alert()`）
>>- `ECMAScript`

>1.5 浏览器中的 `JavaScript` 不可以做什么？
>>- 文件操作（文件和文件夹的`CRUD`）
>>- 没有办法操作系统信息
>>- 由于运行环境特殊（我们写的代码是在不认识的人的浏览器中运行）

>1.6 在开发人员能力相同的情况下编程语言的能力取决于什么？
>>- -语言本身？-
>>- 语言本身只是提供定义变量，定义函数，定义类型，流程控制，循环结构之类的操作
>>- 取决于运行该语言的平台（环境）
>>- 对于JS来说，我们常说的`JS`实际是`ES`，大部分能力都是由浏览器的执行引擎决定
>>- `BOM`和`DOM`可以说是浏览器开放出来的接口
>>- 比如：`Cordova`中提供`JS`调用摄像头，操作本地文件的`API`

### 2、对比其他

>2.1 `Java`
>>- `Java`既是语言也是平台
>>- `Java`运行在`Java虚拟机`（跨操作系统）

>2.2 `PHP`既是语言也是平台（跨操作系统）

>2.3 `C#`语言平台：.NET Framework（Windows）
>>- `C#`可以运行在`MONO`这样的平台
>>- 因为有人需要将`C#`运行在`Linux`平台，所以出现了`MONO`

>2.4 `JavaScript` 只可以运行在浏览器中吗？
>>- 不是
>>- 能运行在哪，取决于，这个环境有没有特定平台

## 二、node.js 思想
### 1、概述

>1.1 描述：
>> `node.js`是一个让`JavaScript`运行在服务端的开发平台。
> 
>> `node.js`不是`JS`应用，而是`JS`运行平台。

>1.2 特点：
>>- 实时响应
>>- 充分考虑超大规模数据要求下架构的可扩展性；
>>- 单线程、异步式`I/O`、事件驱动式的程序设计模型；
（传统是依靠多线程实现高并发的设计思路）
>>- `node.js`在执行的过程中会维护一个事件队列，程序在执行时进入事件循环等待下一个事件到来，每个异步式`I/O`请求完成后会被推送到事件队列，等待程序进程进行处理。

>1.3 优点：
>>- `node.js`使用的是单线程模型，对于所有`I/O`都采用异步式的请求方式，避免了频繁的上下文切换；

### 2、名词解释
#### 2.1 `I/O`操作

磁盘读写或网络通信，统称为`I/O`操作。

#### 2.2 阻塞

线程在执行中如果遇到`I/O`操作，通常要耗费较长的时间，这时操作系统会剥夺这个线程的`CPU`控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。

当`I/O`操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对`CPU`的控制权，令其继续执行。这种`I/O`模式就是通常的同步`I/O`（`Synchronous I/O`）或阻塞式`I/O`（`Blocking I/O`）。

#### 2.3 异步式`I/O`（或非阻塞`I/O`）

异步`I/O`（`Asynchronous I/O`）或非阻塞式`I/O`（`Non-blocking I/O`）则针对所有`I/O`操作不采用阻塞的策略。当线程遇到`I/O`操作时，不会以阻塞的方式等待`I/O`操作的完成或数据的返回，而只是将`I/O`请求发送给操作系统，继续执行下一条语句。当操作系统完成`I/O`操作时，以事件的形式通知执行`I/O`操作的线程，线程会在特定时候处理这个事件。为了处理异步`I/O`，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。

> 阻塞和非阻塞的选择：
>>- 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。
>>- 非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的`CPU`核心利用率永远是`100%`，`I/O`以事件的方式通知。
>>- 在阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞时还有其他线程在工作，多线程可以让`CPU`资源不被阻塞中的线程浪费。
>>- 在非阻塞模式下，线程不会被`I/O`阻塞，永远在利用`CPU`。多线程带来的好处仅仅是在多核`CPU`的情况下利用更多的核，而`node.js`的单线程也能带来同样的好处。这就是为什么`node.js`使用了单线程、非阻塞的事件编程模式。


> `同步式I/O` 和 `异步式I/O`的特点：
>>- `同步式I/O`（阻塞式）
>>>-  利用多线程提供吞吐量
>>>-  通过事件片分割和线程调度利用多核`CPU`
>>>-  需要由操作系统调度多线程使用多核`CPU`
>>>-  难以充分利用`CPU`资源
>>>-  内存轨迹大，数据局部性弱
>>>-  符合线性的编程思维
>
>>- `异步式I/O`（非阻塞式）
>>>- 单线程即可实现高吞吐量
>>>- 通过功能划分利用多核CPU
>>>- 可以将单进程绑定到单核CPU
>>>- 可以充分利用`CPU`资源
>>>- 内存轨迹小，数据局部性强
>>>- 不符合传统编程思维

#### 2.4 事件式编程

`node.js`所有的异步`I/O`操作在完成时都会发送一个事件到事件队列。

>`node.js`的事件循环机制： `nodejs`在什么时候进入事件循环？
>>`node.js`程序由事件循环开始，到事件循环结束，所有的逻辑都是事件的回调函数，所以`node.js`始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出`I/O`请求或直接发射（`emit`）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束。
![事件循环](../image/事件循环.png)

> `node.js`的事件循环对开发者不可见，由`libev`库实现。

> `libev`支持多种类型的事件，在`node.js`中均被`EventEmitter`封装。

>`libev`事件循环的每一次迭代，在`node.js`中就是一次`Tick`，`libev`不断检查是否有活动的、可供检测的事件监听器，直到检测不到时才退出事件循环，进入结束。


## 二、node.js 用途

>- (1) 具有复杂逻辑的网站；
>- (2) 基于设计网络的大规模`Web`应用；
>- (3) `Web Socket`服务器；
>- (4) `TCP/UDP`套接字应用程序；
>- (5) 命令行工具；
>- (6) 交互式终端程序；
>- (7) 带有图形用户界面的本地应用程序；
>- (8) 单元测试工具；
>- (9) 客户端`JavaScript`编译器；
